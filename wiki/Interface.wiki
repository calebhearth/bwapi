#summary How custom AIs can make use of BWAPI

For BWAPI to be a finished API, it should have a simple C++ interface to the outside that can be used directly by custom AIs written in C++ and as a back-end of a LUA interface.

This interface should be feature-complete in the sense that any higher-level behaviors (like SCV-auto balance, build order execution, unit micro, etc) could be fully implemented via this interface. Below is an list of methods that such an interface could have. If you try to get information about units that are not visible, most Unit methods will return the corresponding error from the list below.

= Interface =

== Game Interface ==
  * std::set< Force{{{*}}} > getForces();
  * std::set< Player{{{*}}} > getPlayers();
  * std::set< Unit{{{*}}} > getMinerals();
  * std::set< Unit{{{*}}} > getGeysers();
  * std::set< Unit{{{*}}} > getNeutralUnits();

  * Latency::Enum getLatency();
  * int getFrameCount();

  * std::set< Unit{{{*}}} > unitsOnTile(TilePosition tile);

  * std::set< UnitType > allUnitTypes();
  * UnitType getUnitType(std::string type);

  * std::set< UpgradeType > allUpgrades();
  * UpgradeType getUpgrade(std::string upgrade);

  * std::set< TechType > allTechs();
  * TechType getTech(std::string tech);

  * std::set< RaceType > allRaces();
  * RaceType getRace(std::string race);

  * std::set< OrderType > allOrders();
  * OrderType getOrder(std::string order);

  * Player{{{*}}} self();
  * int shareVision(Player{{{*}}} player);
  * int unshareVision(Player{{{*}}} player);
  * int formAlliance(Player{{{*}}} player);
  * int destroyAlliance(Player{{{*}}} player);

  * int mapWidth();
  * int mapHeight();
  * std::string mapFilename();
  * std::string mapName();
  * bool buildable(BuildTile tile);
  * bool walkable(WalkTile tile);
  * bool visible(BuildTile tile);

  * std::set< TilePosition > getStartLocations();

  * int printText(std::string text);
  * int printText(const char {{{*}}}text, ...);
  * int sendMessage(std::string text);
  * int sendMessage(const char {{{*}}}text, ...);

  * const int BUILD_TILE_SIZE;
  * const int WALK_TILE_SIZE;

== Force Interface  ==
  * std::set< Player{{{*}}} > getPlayers();

== Player Interface ==
  * std::string getName();
  * std::set< Unit{{{*}}} > getUnits();
  * Race getRace();
  * PlayerType playerType();
  * int isAlliesWith(Player{{{*}}} player);
  * Force{{{*}}} getForce();

  * int minerals();
  * int gas();
  * int supplyUsed();
  * int supplyTotal();

  * int getUnitsAll(UnitType type);
  * int getUnitsCompleted(UnitType type);
  * int getUnitsKilled(UnitType type);
  * int getUnitsDead(UnitType type);
  * int getDeaths(BW::UnitType unit);
  * int getKills(BW::UnitType unit);

  * int researching(TechType tech);
  * int researched(TechType tech);
  * int upgrading(UpgradeType upgrade);
  * int getUpgradeLevel(UpgradeType upgrade);

== Unit Interface ==
  * int attackLocation(Position target);
  * int rightClick(Position target);
  * int rightClick(Unit target);
  * int train(UnitType type);
  * int build(BuildLocation p, UnitType type);
  * int invent(Tech tech);
  * int upgrade(Upgrade upgrade);
  * int stop();
  * int holdPosition();
  * int patrol(Position target);
  * int useTech(Tech tech);

  * int visible();
  * Player{{{*}}} getOwner();
  * UnitType getType();
  * int health();
  * int shield();
  * int energy();
  * Position getPosition();
  * BuildTile getTilePosition();
  * Unit{{{*}}} getTarget();
  * Unit{{{*}}} getChild();
  * Unit{{{*}}} getOrderTarget();
  * Unit{{{*}}} getBuildUnit();
  * int remainingBuildTime();
  * Position targetPosition();
  * OrderType getOrder();
  * OrderType getSecondaryOrder();
  * int timer();
  * int exists();
  * int isCompleted();
  * int isLifted();
  * int isBurrowed();
  * int isIdle();
  * int isCloaked();
  * int isDisabled();
  * int isTraining();
  * std::list< UnitType > getTrainingQueue();

== UnitType Interface ==
  * std::set< UnitType > requiredUnits();
  * TechType requiredTech();
  * std::string getName();
  * Race getRace();
  * UnitType whatBuilds();
  * int suppliesConsumed();
  * int suppliesProduced();
  * int maxHealth();
  * int maxShield();
  * int mineralPrice();
  * int gasPrice();
  * int armor();
  * int buildTime();
  * int dimensionLeft();
  * int dimensionUp();
  * int dimensionRight();
  * int dimensionDown();
  * int tileWidth();
  * int tileHeight();
  * int damageFactor();
  * int groundDamage();
  * int canProduce();
  * int isWorker();
  * int canAttack();
  * int canMoves();
  * int isBuilding();
  * int isAddon();
  * int isFlyer();
  * int isNeutral();
  * int isOrganic();
  * int isMechanical();
  
== UpgradeType Interface ==
  * std::string getName();
  * int mineralPrice();
  * int gasPrice();
  * UnitType whatUpgrades();

== TechType Interface ==
  * std::string getName();
  * int mineralPrice();
  * int gasPrice();
  * UnitType whatResearches();

== OrderType Interface ==
  * std::string getName();

== class RaceType ==
  * std::string getName();
  * UnitType workerUnit();

== class Position ==
  * float x();
  * float y();
  * BuildTile getBuildTile();
  * WalkTile getWalkTile();

== class WalkTile ==
  * int x();
  * int y();
  * BuildTile getBuildTile();
  * Posiiton getPosition();

== class BuildTile ==
  * int x();
  * int y();
  * WalkTile getWalkTile();
  * Position getPosition();

== class BuildLocation ==
  * BuildLocation(BuildTile p, int width, int height);
  * BuildLocation(Position p, int width, int height);
  * int getWidth();
  * int getHeight();
  * BuildTile getBuildTile();
  * Position getPosition();

== Error Codes ==
  * ERROR_UNIT_NOT_VISIBLE - returned if you try to retrieve information about a unit that is not currently visible or is dead.
  * ERROR_INCOMPATIBLE_UNIT_TYPE - returned if you do something weird like try to build a Pylon with an SCV, or train Vultures in a Barracks.
  * ERROR_UNIT_NOT_OWNED - returned when attempting to order a unit that BWAPI does not own (i.e. can't order enemy army to go away )
  * ERROR_INSUFFICIENT_MINERALS - returned if you try to train or build something without enough minerals
  * ERROR_INSUFFICIENT_GAS - returned if you try to train or build something without enough vespene gas
  * ERROR_INSUFFICIENT_SUPPLY - returned if you try to train something without enough supply
  * ERROR_INSUFFICIENT_ENERGY - returned if you to do something like try to order a Defiler to cast a Dark Swarm without enough energy.
  * ERROR_UNBUILDABLE_LOCATION - returned if you try to build something on unbuildable terrain (either from the buildability map data or if a unit is in the way). For build tiles that are not visible, we could just use the buildability map data and assume that no units are blocking it (to prevent cheating).
  * ERROR_INCOMPATIBLE_TECH_TYPE - returned if you try to research something at the wrong building, or try to use a tech type that is not researched, or if you try to order a unit to use tech that is meant for another unit (i.e. trying order a Zerg Spire to Burrow will return this error)
  * ERROR_INCOMPATIBLE_UPGRADE_TYPE - returned if you try to upgrade something at the wrong building
  * ERROR_INSUFFICIENT_TECH - returned if you do something like try to train Medics when you don't have an Academy, or try to lay Spider Mines before spider mines have been researched.
  * ERROR_INSUFFICIENT_AMMO - returned if you do something like try to lay Spider Mines when your Vulture is out of Spider Mines. Same thing with Reavers and Scarabs.
  * ERROR_OUT_OF_RANGE - returned if you order an immovable unit to attack a unit that is out of range.
  * ERROR_UNABLE_TO_HIT - returned if you do something like order a Vulture to attack a flying unit.