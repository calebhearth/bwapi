#summary How custom AIs can make use of BWAPI

For BWAPI to be a finished API, it should have a simple C++ interface to the outside that can be used directly by custom AIs written in C++ and as a back-end of a LUA interface.

This interface should be feature-complete in the sense that any higher-level behaviors (like SCV-auto balance, build order execution, unit micro, etc) could be fully implemented via this interface. Below is an list of methods that such an interface could have. If you try to get information about units that are not visible, most Unit methods will return the corresponding error from the list below.

= Interface =

== Global commands (within BWAPI namespace) ==
  * std::set< Force > getForces();
  * std::set< Player > getPlayers();
  * std::set< Unit > getMinerals();
  * std::set< Unit > getGeysers();
  * std::set< Unit > getNeutralUnits();

  * Latency::Enum getLatency();
  * int getFrameCount();

  * std::set< Unit > unitsOnTile(TilePosition tile);

  * std::set< UnitType > allUnitTypes();
  * UnitType getUnitType(std::string type);

  * std::set< Upgrade > allUpgrades();
  * Upgrade getUpgrade(std::string upgrade);

  * std::set< Tech > allTechs();
  * Tech getTech(std::string tech);

  * std::set< Race > allRaces();
  * Race getRace(std::string race);

  * std::set< Order > allOrders();
  * Order getOrder(std::string order);

  * Player self();
  * int shareVision(Player player);
  * int unshareVision(Player player);
  * int formAlliance(Player player);
  * int destroyAlliance(Player player);

  * int mapWidth();
  * int mapHeight();
  * std::string mapFilename();
  * std::string mapName();
  * bool buildable(BuildTile tile);
  * bool walkable(WalkTile tile);
  * bool visible(BuildTile tile);

  * std::set< TilePosition > getStartLocations();

  * int printText(std::string text);
  * int printText(const char {{{*}}}text, ...);
  * int sendMessage(std::string text);
  * int sendMessage(const char {{{*}}}text, ...);

  * const int BUILD_TILE_SIZE;
  * const int WALK_TILE_SIZE;

== class Force methods ==
  * std::set< Player > getPlayers();

== class Player methods ==
  * std::set< Unit > getUnits();
  * std::string getName();
  * Race getRace();
  * PlayerType playerType();
  * int isAlliesWith(Player player);
  * Force getForce();
  * int researching(Tech tech);
  * int researched(Tech tech);
  * int upgrading(Upgrade upgrade);
  * int getUpgradeLevel(Upgrade upgrade);
  * int minerals();
  * int gas();
  * int supplyUsed();
  * int supplyTotal();
  * int unitsAll(UnitType type);
  * int unitsCompleted(UnitType type);
  * int unitsKilled(UnitType type);
  * int unitsDead(UnitType type);

== class Unit methods ==
  * int attackLocation(Position target);
  * int rightClick(Position target);
  * int rightClick(Unit target);
  * int train(UnitType type);
  * int build(BuildTile tile, UnitType type);
  * int invent(Tech tech);
  * int upgrade(Upgrade upgrade);
  * int stop();
  * int holdPosition();
  * int patrol(Position target);
  * int useTech(Tech tech);

  * int visible();
  * Player getOwner();
  * UnitType getType();
  * int health();
  * int shield();
  * int energy();
  * Position getPosition();
  * BuildTile getTilePosition();
  * Unit getTarget();
  * Unit getChild();
  * Unit getOrderTarget();
  * Unit getBuildUnit();
  * int remainingBuildTime();
  * Position targetPosition();
  * Order getOrder();
  * Order getSecondaryOrder();
  * int timer();
  * int exists();
  * int isCompleted();
  * int isLifted();
  * int isBurrowed();
  * int isIdle();
  * int isCloaked();
  * int isDisabled();
  * int isTraining();
  * std::list< UnitType > getTrainingQueue();

== class UnitType methods ==
  * std::set< UnitType > requiredUnits();
  * Tech requiredTech();
  * std::string getName();
  * Race getRace();
  * UnitType whatBuilds();
  * int suppliesConsumed();
  * int suppliesProduced();
  * int maxHealth();
  * int maxShield();
  * int mineralPrice();
  * int gasPrice();
  * int armor();
  * int buildTime();
  * int dimensionLeft();
  * int dimensionUp();
  * int dimensionRight();
  * int dimensionDown();
  * int tileWidth();
  * int tileHeight();
  * int damageFactor();
  * int groundDamage();
  * int canProduce();
  * int isWorker();
  * int canAttack();
  * int canMoves();
  * int isBuilding();
  * int isAddon();
  * int isFlyer();
  * int isNeutral();
  * int isOrganic();
  * int isMechanical();
  
== class Upgrade methods ==
  * std::string getName();
  * int mineralPrice();
  * int gasPrice();
  * UnitType whatUpgrades();

== class Tech methods ==
  * std::string getName();
  * int mineralPrice();
  * int gasPrice();
  * UnitType whatResearches();

== class Order methods ==
  * std::string getName();

== class Race methods ==
  * std::string getName();

== class Position methods ==
  * float x();
  * float y();
  * BuildTile getBuildTile();
  * WalkTile getWalkTile();

== class WalkTile methods ==
  * int x();
  * int y();
  * BuildTile getBuildTile();
  * Posiiton getPosition();

== class BuildTile methods ==
  * int x();
  * int y();
  * WalkTile getWalkTile();
  * Position getPosition();

== Error Codes ==
  * ERROR_UNIT_NOT_VISIBLE - returned if you try to retrieve information about a unit that is not currently visible or is dead.
  * ERROR_INCOMPATIBLE_UNIT_TYPE - returned if you do something weird like try to build a Pylon with an SCV, or train Vultures in a Barracks.
  * ERROR_UNIT_NOT_OWNED - returned when attempting to order a unit that BWAPI does not own (i.e. can't order enemy army to go away )
  * ERROR_INSUFFICIENT_MINERALS - returned if you try to train or build something without enough minerals
  * ERROR_INSUFFICIENT_GAS - returned if you try to train or build something without enough vespene gas
  * ERROR_INSUFFICIENT_SUPPLY - returned if you try to train something without enough supply
  * ERROR_INSUFFICIENT_ENERGY - returned if you to do something like try to order a Defiler to cast a Dark Swarm without enough energy.
  * ERROR_UNBUILDABLE_LOCATION - returned if you try to build something on unbuildable terrain (either from the buildability map data or if a unit is in the way). For build tiles that are not visible, we could just use the buildability map data and assume that no units are blocking it (to prevent cheating).
  * ERROR_INCOMPATIBLE_TECH_TYPE - returned if you try to research something at the wrong building, or try to use a tech type that is not researched, or if you try to order a unit to use tech that is meant for another unit (i.e. trying order a Zerg Spire to Burrow will return this error)
  * ERROR_INCOMPATIBLE_UPGRADE_TYPE - returned if you try to upgrade something at the wrong building
  * ERROR_INSUFFICIENT_TECH - returned if you do something like try to train Medics when you don't have an Academy, or try to lay Spider Mines before spider mines have been researched.
  * ERROR_INSUFFICIENT_AMMO - returned if you do something like try to lay Spider Mines when your Vulture is out of Spider Mines. Same thing with Reavers and Scarabs.
  * ERROR_OUT_OF_RANGE - returned if you order an immovable unit to attack a unit that is out of range.
  * ERROR_UNABLE_TO_HIT - returned if you do something like order a Vulture to attack a flying unit.