#summary How custom AIs can make use of BWAPI

For BWAPI to be a finished API, it should have a simple C++ interface to the outside that can be used directly by custom AIs written in C++ and as a back-end of a LUA interface.

This interface should be feature-complete in the sense that any higher-level behaviors (like SCV-auto balance, build order execution, unit micro, etc) could be fully implemented via this interface. Below is an list of methods that such an interface could have. If you try to get information about units that are not visible, most Unit methods will return the corresponding error from the list below.

= Interface =

== Game ==
  * std::set< Force{{{*}}} > getForces();
  * std::set< Player{{{*}}} > getPlayers();
  * std::set< Unit{{{*}}} > getAllUnits();
  * std::set< Unit{{{*}}} > getMinerals();
  * std::set< Unit{{{*}}} > getGeysers();
  * std::set< Unit{{{*}}} > getNeutralUnits();

  * Latency::Enum getLatency();
  * int getFrameCount();
  * int getMouseX();
  * int getMouseY();
  * int getScreenX();
  * int getScreenY();
  * bool isFlagEnabled(Flag::Enum flag);
  * void enableFlag(Flag::Enum flag);
  * std::set< Unit{{{*}}} > unitsOnTile(TilePosition tile);

  * int mapWidth();
  * int mapHeight();
  * std::string mapFilename();
  * std::string mapName();
  * bool buildable(int x, int y);
  * bool walkable(int x, int y);
  * bool visible(int x, int y);
  * int groundHeight(int x, int y);
  * std::set< TilePosition >& getStartLocations();
  * int getMapHash();

  * int print(const char {{{*}}}text, ...);
  * int printPublic(const char {{{*}}}text, ...);
  * void changeRace(Race race);
  * void startGame();
  * void pauseGame();
  * void resumeGame();
  * td::set<Unit{{{*}}}>& getSelectedUnits();
  * Player{{{*}}} self();
  * Player{{{*}}} enemy();

== Force ==
  * std::string getName();
  * std::set< Player{{{*}}} > getPlayers();

== Player ==
  * std::string getName();
  * std::set< Unit{{{*}}} > getUnits();
  * Race getRace();
  * PlayerType playerType();
  * Force{{{*}}} getForce();
  * int isAlliesWith(Player{{{*}}} player);
  * int getID();
  * TilePosition getStartLocation();

  * int minerals();
  * int gas();
  * int supplyTotal();
  * int supplyUsed();

  * int getAllUnits(UnitType type);
  * int getCompletedUnits(UnitType type);
  * int getKilledUnits(UnitType type);
  * int getDeaths(BW::UnitType unit);
  * int getKills(BW::UnitType unit);

  * bool researching(TechType tech);
  * bool researched(TechType tech);
  * bool upgrading(UpgradeType upgrade);
  * int upgradeLevel(UpgradeType upgrade);

== Unit ==
  * Player{{{*}}} getOwner();
  * UnitType getType();
  * int health();
  * int shield();
  * int energy();
  * Position getPosition();
  * TilePosition getTilePosition();

  * Unit{{{*}}} getTarget();
  * Position getTargetPosition();
  * Order getOrder();
  * Unit{{{*}}} getOrderTarget();
  * int getOrderTimer();
  * Order getSecondaryOrder();
  * Unit{{{*}}} getBuildUnit();
  * int getRemainingBuildTime();
  * Unit{{{*}}} getChild();

  * bool isLoaded();
  * bool isVisible();
  * bool isSelected();
  * bool isCompleted();
  * bool isLifted();
  * bool isBurrowed();
  * bool isIdle();
  * bool isCloaked();
  * bool isDisabled();
  * bool isTraining();
  * std::list< UnitType > getTrainingQueue();


  * int attackMove(Position target);
  * int rightClick(Position target);
  * int rightClick(Unit{{{*}}} target);
  * int train(UnitType type);
  * int build(TilePosition p, UnitType type);
  * int invent(TechType tech);
  * int upgrade(UpgradeType upgrade);
  * int stop();
  * int holdPosition();
  * int patrol(Position target);
  * int useTech(Tech tech);
  * int useTech(Tech tech, Position position);
  * int useTech(Tech tech, Unit{{{*}}} target);

== UnitType ==
  * int getID();
  * std::string getName();
  * Race getRace();
  * std::pair< UnitType{{{*}}}, int > whatBuilds();
  * std::map< UnitType{{{*}}}, int > requiredUnits();
  * TechType{{{*}}} requiredTech();
  * int suppliesConsumed();
  * int suppliesProduced();
  * int maxHealth();
  * int maxShield();
  * int maxEnergy();
  * int mineralPrice();
  * int gasPrice();
  * int armor();
  * int buildTime();
  * int dimensionLeft();
  * int dimensionUp();
  * int dimensionRight();
  * int dimensionDown();
  * int tileWidth();
  * int tileHeight();
  * int damageFactor();
  * int groundDamage();
  * int canProduce();
  * int canAttack();
  * int canMoves();
  * int isWorker();
  * int isBuilding();
  * int isAddon();
  * int isFlyer();
  * int isNeutral();
  * int isOrganic();
  * int isMechanical();
  
== UpgradeType ==
  * int getID();
  * std::string getName();
  * Race getRace();
  * int mineralPriceBase();
  * int mineralPriceFactor();
  * int gasPriceBase();
  * int gasPriceFactor();
  * UnitType{{{*}}} whatUpgrades();

== TechType ==
  * int getID();
  * std::string getName();
  * Race getRace();
  * int mineralPrice();
  * int gasPrice();
  * int energyPrice();
  * UnitType{{{*}}} whatResearches();

== Order ==
  * int getID();
  * std::string getName();

== Race ==
  * int getID();
  * std::string getName();

== Position ==
  * int x;
  * int y;
  * double getDistance(Position position);

== TilePosition==
  * int x;
  * int y;
  * bool isValid();

== Error Codes (Not implemented yet) ==
  * ERROR_UNIT_NOT_VISIBLE - returned if you try to retrieve information about a unit that is not currently visible or is dead.
  * ERROR_INCOMPATIBLE_UNIT_TYPE - returned if you do something weird like try to build a Pylon with an SCV, or train Vultures in a Barracks.
  * ERROR_UNIT_NOT_OWNED - returned when attempting to order a unit that BWAPI does not own (i.e. can't order enemy army to go away )
  * ERROR_INSUFFICIENT_MINERALS - returned if you try to train or build something without enough minerals
  * ERROR_INSUFFICIENT_GAS - returned if you try to train or build something without enough vespene gas
  * ERROR_INSUFFICIENT_SUPPLY - returned if you try to train something without enough supply
  * ERROR_INSUFFICIENT_ENERGY - returned if you to do something like try to order a Defiler to cast a Dark Swarm without enough energy.
  * ERROR_UNBUILDABLE_LOCATION - returned if you try to build something on unbuildable terrain (either from the buildability map data or if a unit is in the way). For build tiles that are not visible, we could just use the buildability map data and assume that no units are blocking it (to prevent cheating).
  * ERROR_INCOMPATIBLE_TECH_TYPE - returned if you try to research something at the wrong building, or try to use a tech type that is not researched, or if you try to order a unit to use tech that is meant for another unit (i.e. trying order a Zerg Spire to Burrow will return this error)
  * ERROR_INCOMPATIBLE_UPGRADE_TYPE - returned if you try to upgrade something at the wrong building
  * ERROR_INSUFFICIENT_TECH - returned if you do something like try to train Medics when you don't have an Academy, or try to lay Spider Mines before spider mines have been researched.
  * ERROR_INSUFFICIENT_AMMO - returned if you do something like try to lay Spider Mines when your Vulture is out of Spider Mines. Same thing with Reavers and Scarabs.
  * ERROR_OUT_OF_RANGE - returned if you order an immovable unit to attack a unit that is out of range.
  * ERROR_UNABLE_TO_HIT - returned if you do something like order a Vulture to attack a flying unit.