#summary How custom AIs can make use of BWAPI

For BWAPI to be a finished API, it should have a simple C++ interface to the outside that can be used directly by custom AIs written in C++ and as a back-end of a LUA interface and possibly high-level AI logic parsers for BWAI's XML build order files or Broodwar's current AI scripts.

This interface should be feature-complete in the sense that any higher-level behaviors (like SCV-auto balance, build order execution, unit micro, etc) could be fully implemented via this interface. Below is an list of methods that such an interface could have. UnitID, PlayerID, ForceID, and StartLocationID are integers. UnitTypeID, UpgradeID, TechID, RaceID, and Latency are enums. If you try to get information about UnitIDs that are not visible, most methods will return the corresponding error from the list below.

= Interface =

== Issue commands ==
  * int attackLocation(UnitID unit, int x, int y);
  * int rightClick(UnitID unit, int x, int y);
  * int rightClick(UnitID unit, UnitID target);
  * int train(UnitID unit, UnitTypeID::Enum type);
  * int build(UnitID unit, int x, int y, UnitTypeID::Enum type);
  * int invent(UnitID unit, TechTypeID::Enum tech);
  * int upgrade(UnitID unit, UpgradeTypeID::Enum upgrade);
  * int stop(UnitID unit);
  * int holdPosition(UnitID unit);
  * int patrol(UnitID unit, int x, int y);
  * int useTech(UnitID unit,TechTypeID::Enum tech);

== Get game information ==
Only units that are visible to the AI are returned to prevent cheating.

  * std::set< ForceID > getForces();
  * std::set< PlayerID > getPlayers();
  * std::set< UnitID > getUnits(PlayerID p);
  * std::set< UnitID > getMinerals();
  * std::set< UnitID > getQeysers();
  * std::set< UnitID > getNeutralUnits();
  * Latency::Enum getLatency();
  * int getFrameCount();

== Get information about units ==
  * std::set< UnitID > unitsOnTile(int x, int y);

Can be used on any UnitID
  * int unitVisible(UnitID unit);

If the AI tries to use one of the following methods on a unit that is not visible, an error code will be returned.
  * PlayerID unitOwner(UnitID unit);
  * UnitTypeID::Enum unitType(UnitID unit);
  * int unitHealth(UnitID unit);
  * int unitShield(UnitID unit);
  * int unitEnergy(UnitID unit);
  * int unitPositionX(UnitID unit);
  * int unitPositionY(UnitID unit);
  * int unitTileX(UnitID unit);
  * int unitTileY(UnitID unit);
  * UnitID getTarget(UnitID unit);
  * UnitID getChild(UnitID unit);
  * UnitID getOrderTarget(UnitID unit);
  * UnitID getBuildUnit(UnitID unit);
  * int remainingBuildTime(UnitID unit);
  * int targetPositionX(UnitID unit);
  * int targetPositionY(UnitID unit);
  * OrderID::Enum getOrder(UnitID unit);
  * OrderID::Enum getSecondaryOrder(UnitID unit);
  * int orderTimer(UnitID unit);
  * int unitExists(UnitID unit);
  * int unitCompleted(UnitID unit);
  * int unitLifted(UnitID unit);
  * int unitBurrowed(UnitID unit);
  * int unitIdle(UnitID unit);
  * int unitCloaked(UnitID unit);
  * int unitDisabled(UnitID unit);
  * int isTraining(UnitID unit);

The following method will return an error code if used on any unit that the AI player does not own.
  * std::list< UnitTypeID::Enum > getTrainingQueue(UnitID unit);

== Get information about types of units ==
  * std::set< UnitTypeID::Enum > allUnitTypes();
  * UnitTypeID::Enum getUnitType(std::string type);
  * std::string unitTypeName(UnitTypeID::Enum type);
  * RaceID::Enum unitTypeRace(UnitTypeID::Enum type);
  * UnitTypeID::Enum whatBuilds(UnitTypeID::Enum type);
  * int suppliesConsumed(UnitTypeID::Enum type);
  * int suppliesProduced(UnitTypeID::Enum type);
  * int maxHealth(UnitTypeID::Enum type);
  * int maxShield(UnitTypeID::Enum type);
  * int mineralPrice(UnitTypeID::Enum type);
  * int gasPrice(UnitTypeID::Enum type);
  * int armor(UnitTypeID::Enum type);
  * int buildTime(UnitTypeID::Enum type);
  * int dimensionLeft(UnitTypeID::Enum type);
  * int dimensionUp(UnitTypeID::Enum type);
  * int dimensionRight(UnitTypeID::Enum type);
  * int dimensionDown(UnitTypeID::Enum type);
  * int tileWidth(UnitTypeID::Enum type);
  * int tileHeight(UnitTypeID::Enum type);
  * int damageFactor(UnitTypeID::Enum type);
  * int groundDamage(UnitTypeID::Enum type);
  * int produces(UnitTypeID::Enum type);
  * int worker(UnitTypeID::Enum type);
  * int attacks(UnitTypeID::Enum type);
  * int moves(UnitTypeID::Enum type);
  * int building(UnitTypeID::Enum type);
  * int addon(UnitTypeID::Enum type);
  * int flies(UnitTypeID::Enum type);
  * int neutral(UnitTypeID::Enum type);
  * int organic(UnitTypeID::Enum type);
  * int mechanical(UnitTypeID::Enum type);

== Get information about upgrades ==
  * std::set< UpgradeID::Enum > allUpgrades();
  * std::string upgradeName(UpgradeID::Enum upgrade);
  * UpgradeID::Enum getUpgrade(std::string upgrade);
  * int mineralPrice(UpgradeID::Enum type);
  * int gasPrice(UpgradeID::Enum type);
  * UnitTypeID::Enum whatUpgrades(UpgradeID::Enum type);

== Get information about tech ==
  * std::set< TechID::Enum > allTechs();
  * TechID::Enum getTech(std::string tech);
  * std::string techName(TechID::Enum tech);
  * int mineralPrice(TechID::Enum type);
  * int gasPrice(TechID::Enum type);
  * UnitTypeID::Enum whatResearches(TechID::Enum type);

== Get information about orders ==
  * std::set< OrderID::Enum > allOrders();
  * OrderID::Enum getOrder(std::string order);
  * std::string orderName(OrderID::Enum order);

== Get information about races ==
  * std::set<RaceID::Enum> allRaces();
  * RaceID::Enum getRace(std::string race);
  * std::string raceName(RaceID::Enum race);

== Get information about our player ==
  * int researching(TechID::Enum tech);
  * int researched(TechID::Enum tech);
  * int upgrading(UpgradeID::Enum upgrade);
  * int getUpgradeLevel(UpgradeID::Enum upgrade);
  * int minerals();
  * int gas();
  * int supplyUsed();
  * int supplyTotal();
  * PlayerID myID();
  * int unitsAll(UnitTypeID::Enum type);
  * int unitsCompleted(UnitTypeID::Enum type);
  * int unitsKilled(UnitTypeID::Enum type);
  * int unitsDead(UnitTypeID::Enum type);

== Get information about any player ==
  * std::string playerName(PlayerID player);
  * RaceID::Enum playerRace(PlayerID player);
  * PlayerTypeID::Enum playerType(PlayerID player);
  * int areAllies(PlayerID player1, PlayerID player2);
  * ForceID getForce(PlayerID player);

== Get map information ==
  * int mapWidth();
  * int mapHeight();
  * std::string mapFilename();
  * std::string mapName();
  * bool buildable(int x, int y);
  * bool walkable(int x, int y);
  * bool visible(int x, int y);

The following function returns a list of all the possible starting location for the given map, not the actual starting locations for the current match.
  * std::set< StartLocationID > getStartLocations();
  * int startLocationX(StartLocationID location);
  * int startLocationY(StartLocationID location);

== Misc ==
  * int printText(std::string text);
  * int printText(const char *text, ...);
  * int sendMessage(std::string text);
  * int sendMessage(const char *text, ...);

  * int shareVision(PlayerID player);
  * int unshareVision(PlayerID player);
  * int formAlliance(PlayerID player);
  * int destroyAlliance(PlayerID player);

  * const int TILE_SIZE;

== Error Codes ==
  * ERROR_UNIT_NOT_VISIBLE - returned if you try to retrieve information about a unit that is not currently visible or is dead.
  * ERROR_INCOMPATIBLE_UNIT_TYPE - returned if you do something weird like try to build a Pylon with an SCV, or train Vultures in a Barracks.
  * ERROR_UNIT_NOT_OWNED - returned when attempting to order a unit that BWAPI does not own (i.e. can't order enemy army to go away )
  * ERROR_INSUFFICIENT_MINERALS - returned if you try to train or build something without enough minerals
  * ERROR_INSUFFICIENT_GAS - returned if you try to train or build something without enough vespene gas
  * ERROR_INSUFFICIENT_SUPPLY - returned if you try to train something without enough supply
  * ERROR_INSUFFICIENT_ENERGY - returned if you to do something like try to order a Defiler to cast a Dark Swarm without enough energy.
  * ERROR_UNBUILDABLE_LOCATION - returned if you try to build something on unbuildable terrain (either from the buildability map data or if a unit is in the way). For build tiles that are not visible, we could just use the buildability map data and assume that no units are blocking it (to prevent cheating).
  * ERROR_INCOMPATIBLE_TECH_TYPE - returned if you try to research something at the wrong building, or try to use a tech type that is not researched, or if you try to order a unit to use tech that is meant for another unit (i.e. trying order a Zerg Spire to Burrow will return this error)
  * ERROR_INCOMPATIBLE_UPGRADE_TYPE - returned if you try to upgrade something at the wrong building
  * ERROR_INSUFFICIENT_TECH - returned if you do something like try to train Medics when you don't have an Academy, or try to lay Spider Mines before spider mines have been researched.
  * ERROR_INSUFFICIENT_AMMO - returned if you do something like try to lay Spider Mines when your Vulture is out of Spider Mines. Same thing with Reavers and Scarabs.
  * ERROR_OUT_OF_RANGE - returned if you order an immovable unit to attack a unit that is out of range.
  * ERROR_UNABLE_TO_HIT - returned if you do something like order a Vulture to attack a flying unit.