= Latency =
#L = count of frames before commands take effect.
(Because you must distribute the command to all players)
So when you order command, #L frames nothing happends, as it would be annoying to workaround the latency in the code that uses the bwapi I decided (and Goosy doesn't like it) to make workaround tool for that directly in our bw api.

We will have 3 versions of bw data.
1) BW data in the memory that bw uses directly
2) Our copy (that is made every frame), so some multithread version could work with that without problems
3) Partialy precomputed version of data

I will explain on example, lets assume you ordered your command center to start building scv, but #L the command center will still not start the build, so code like if (cc->notBuilding) buildScv, will order the command to build the scv #L + 1 times.

So when you do builSCV command, the bwapi library will call that command, but also store it in buffer, and keep it #L frames, then every frame, we will make fresh copy of bw data (3), and apply all commands stored in the buffer manualy.

so the code will be (cc->precomputed->notBuilding) -> buildSCV, the preComputed state will change immedeatly.

The user of the library must be aware, that we can't guarantee that the preComputed state will really occur, for example if you order to build scv, and just before the command gets executed you lose minerals, the command will fail.

= Multithread issues =

We already tested out, that calling bw functions in different thread while bw is runnig is dangerous, and can result in crash occasionaly, so we decided to run all bw functions directly from the bw tread (by hooking interal bw function and taking the tread for that).

Later on, we will implement multithread version, where you can let ai to run in different treads, but all bw function calls will be buffered, and flushed once per frame from the bw thread.