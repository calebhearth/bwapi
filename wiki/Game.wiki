#sidebar TableOfContents

Class header file: [http://code.google.com/p/bwapi/source/browse/trunk/bwapi/include/BWAPI/Game.h# BWAPI/Game.h]

The abstract Game class is implemented by BWAPI and offers many methods for retrieving information about the current Broodwar game, including the set of players, units, map information, as well as information about the user, such as mouse position, screen position, and the current selection of units.

Methods:

  * [#getForces getForces]
  * [#getPlayers getPlayers]
  * [#getAllUnits getAllUnits]
  * [#getMinerals getMinerals]
  * [#getGeysers getGeysers]
  * [#getNeutralUnits getNeutralUnits]

  * [#getStaticMinerals getStaticMinerals]
  * [#getStaticGeysers getStaticGeysers]
  * [#getStaticNeutralUnits getStaticNeutralUnits]

  * [#getLatency getLatency]
  * [#getFrameCount getFrameCount]
  * [#getMouseX getMouseX]
  * [#getMouseY getMouseY]
  * [#getMousePosition getMousePosition]
  * [#getMouseState getMouseState]
  * [#getKeyState getKeyState]
  * [#getScreenX getScreenX]
  * [#getScreenY getScreenY]
  * [#getScreenPosition getScreenPosition]
  * [#setScreenPosition setScreenPosition]
  * [#pingMinimap pingMinimap]
  * [#isFlagEnabled isFlagEnabled]
  * [#enableFlag enableFlag]
  * [#unitsOnTile unitsOnTile]
  * [#getLastError getLastError]

  * [#mapWidth mapWidth]
  * [#mapHeight mapHeight]
  * [#mapFilename mapFilename]
  * [#mapName mapName]
  * [#getMapHash getMapHash]
  * [#getGroundHeight getGroundHeight]
  * [#isWalkable isWalkable]
  * [#isBuildable isBuildable]
  * [#isVisible isVisible]
  * [#isExplored isExplored]
  * [#hasCreep hasCreep]
  * [#hasPower hasPower]
  * [#canBuildHere canBuildHere]
  * [#canMake canMake]
  * [#canResearch canResearch]
  * [#canUpgrade canUpgrade]
  * [#getStartLocations getStartLocations]

  * [#printf printf]
  * [#sendText sendText]
  * [#changeRace changeRace]
  * [#isMultiplayer isMultiplayer]
  * [#isPaused isPaused]
  * [#isReplay isReplay]
  * [#startGame startGame]
  * [#pauseGame pauseGame]
  * [#resumeGame resumeGame]
  * [#leaveGame leaveGame]
  * [#restartGame restartGame]
  * [#setLocalSpeed setLocalSpeed]
  * [#getSelectedUnits getSelectedUnits]
  * [#self self]
  * [#enemy enemy]

  * [#drawText drawText]
  * [#drawBox drawBox]
  * [#drawCircle drawCircle]
  * [#drawEllipse drawEllipse]
  * [#drawDot drawDot]
  * [#drawLine drawLine]
  * [#drawTriangle drawTriangle]

=== getForces ===
std::set< [Force]{{{*}}} >& getForces();

Returns the set of all forces in the match.

=== getPlayers ===
std::set< [Player]{{{*}}} >& getPlayers();

Returns the set of all players in the match. Note that this includes the Neutral player, which owns all the neutral units such as minerals, critters, etc.

=== getAllUnits ===
std::set< [Unit]{{{*}}} >& getAllUnits();

Returns all the visible units. If [Flag]::CompleteMapInformation is enabled, the set of all units is returned, not just visible ones. Note that units inside refineries are not included in this set yet.

=== getMinerals ===
std::set< [Unit]{{{*}}} >& getMinerals();

Returns the set of all accessible mineral patches.

=== getGeysers ===
std::set< [Unit]{{{*}}} >& getGeysers();

Returns the set of all accessible vespene geysers.

=== getNeutralUnits ===
std::set< [Unit]{{{*}}} >& getNeutralUnits();

Returns the set of all accessible neutral units.

=== getStaticMinerals ===
std::set< [Unit]{{{*}}} >& getStaticMinerals();

Returns the set of all mineral patches (including mined out and other inaccessible ones).

=== getStaticGeysers ===
std::set< [Unit]{{{*}}} >& getStaticGeysers();

Returns the set of all vespene geysers (including mined out and other inaccessible ones).

=== getStaticNeutralUnits ===
std::set< [Unit]{{{*}}} >& getStaticNeutralUnits();

Returns the set of all neutral units (including mined out and other inaccessible ones).

=== getLatency ===
Latency::Enum getLatency();

Returns the amount of latency the current game has. Currently only returns Latency::SinglePlayer, Latency::LanLow, Latency::LanMedium, or Latency::LanHigh.

=== getFrameCount ===
int getFrameCount();

Returns the number of logical frames since the match started. If the game is paused, Game::getFrameCount will not increase however AIModule::onFrame will still be called while paused. On Fastest, there are about 23.8 - 24 frames per second.

=== getMouseX ===
int getMouseX();

Returns the horizontal coordinate of the mouse on the screen. Returns 0 if Flag::UserInput is disabled.

=== getMouseY ===
int getMouseY();

Returns the vertical coordinate of the mouse on the screen. Returns 0 if Flag::UserInput is disabled.

=== getMousePosition ===
BWAPI::Position getMousePosition();

Returns the position of the mouse on the screen.

=== getMouseState ===
bool getMouseState([Input#MouseButton MouseButton] button);

bool getMouseState(int button);

Returns true if the specified mouse button is pressed. Returns false if Flag::UserInput is disabled.

=== getKeyState ===
bool getKeyState([Input#Key] key);

bool getKeyState(int key);

Returns true if the specified key is pressed. Returns false if Flag::UserInput is disabled. For now these values are not raw keyboard input - i.e. it automatically alternates between true and false when you hold a key down.

=== getScreenX ===
int getScreenX();

Returns the horizontal coordinate of the screen on the map. Returns 0 if Flag::UserInput is disabled.

=== getScreenY ===
int getScreenY();

Returns the vertical coordinate of the screen on the map. Returns 0 if Flag::UserInput is disabled.

=== getScreenPosition ===
BWAPI::Position getScreenPosition();

Returns the position of the top left corner of the screen on the map.

=== setScreenPosition ===
void setScreenPosition(int x, int y);

void setScreenPosition(BWAPI::Position p);

Moves the screen to the given position on the map. The position specified where the top left corner of the screen will be.

=== pingMinimap ===
void pingMinimap(int x, int y);

void pingMinimap(BWAPI::Position p);

Pings the given position on the minimap.

=== isFlagEnabled ===
bool isFlagEnabled([Misc#Flag::Enum Flag::Enum] flag);

Returns true if the given flag has been enabled. Note that flags can only be enabled at the beginning of a match, during the [AIModule]::onStart callback.

=== enableFlag ===
void enableFlag([Misc#Flag::Enum Flag::Enum] flag);

Enables the specified flag. Note that flags can only be enabled at the beginning of a match, during the [AIModule]::onStart callback.

=== unitsOnTile ===
std::set< [Unit]{{{*}}} >& unitsOnTile(int x, int y);

Returns the set of units that are on the given build tile. Only returns accessible units on accessible tiles.

=== getLastError ===
[Error] getLastError() const;

Returns the last error that was set. If you try to order enemy units around, or morph bunkers into lurkers, BWAPI will set error codes, which can be retrieved using this function.

=== mapWidth ===
int mapWidth();

Returns the width of the current map, in build tile units. To get the width of the current map in walk tile units, multiply by 4. To get the width of the current map in [Misc#Position Position] units, multiply by [Misc#Constants TILE_SIZE] (which is 32).

=== mapHeight ===
int mapHeight();

Returns the height of the current map, in build tile units. To get the height of the current map in walk tile units, multiply by 4. To get the height of the current map in [Misc#Position Position] units, multiply by [Misc#Constants TILE_SIZE] (which is 32).

=== mapFilename ===
std::string mapFilename();

Returns the file name of the current map.

=== mapName ===
std::string mapName();

Returns the name/title of the current map.

=== getMapHash ===
int getMapHash();

Returns a unique identifier for the given map data that does not depend on the file name.

=== getGroundHeight ===
int getGroundHeight(int x, int y);

Returns the ground height of the given walk tile. 0 = normal, 1 = high ground.

=== isWalkable ===
bool isWalkable(int x, int y);

Returns true if the specified walk tile is walkable. The values of x and y are in walk tile coordinates (different from build tile coordinates). Note that this just uses the static map data. You will also need to make sure no ground units are on the coresponding build tile to see if its currently walkable. To do this, see [#unitsOnTile unitsOnTile].

=== isBuildable ===
bool isBuildable(int x, int y);

bool isBuildable([Misc#TilePosition TilePosition] position);

Returns true if the specified build tile is buildable. Note that this just uses the static map data. You will also need to make sure no ground units on the tile to see if its currently buildable. To do this, see [#unitsOnTile unitsOnTile].

=== isVisible ===
bool isVisible(int x, int y);

bool isVisible([Misc#TilePosition TilePosition] position);

Returns true if the specified build tile is visible. If the tile is concealed by fog of war, the function will return false.

=== isExplored ===
bool isExplored(int x, int y);

bool isExplored([Misc#TilePosition TilePosition] position);

Returns true if the specified build tile has been explored (i.e. was visible at some point in the match).

=== hasCreep ===
bool hasCreep(int x, int y);

bool hasCreep([Misc#TilePosition TilePosition] position);

Returns true if the specified build tile has zerg creep on it. If the tile is concealed by fog of war, the function will return false.

=== hasPower ===
bool hasPower(int x, int y, int tileWidth, int tileHeight);

bool hasPower([Misc#TilePosition TilePosition] position, int tileWidth, int tileHeight);

Returns true if the given build location is powered by a nearby friendly pylon.

=== canBuildHere ===
bool canBuildHere([Unit]{{{*}}} builder, [Misc#TilePosition TilePosition] position, [UnitType] type);

Returns true if the given unit type can be built at the given build tile position. Note the tile position specifies the top left tile of the building. If builder is not null, the unit will be discarded when determining whether or not any ground units are blocking the build location.

=== canMake ===
bool canMake([Unit]{{{*}}} builder, [UnitType] type);

Returns true if the AI player has enough resources, supply, tech, and required units in order to make the given unit type. If builder is not null, canMake will return true only if the builder unit can build the given unit type.

=== canResearch ===
bool canResearch([Unit]{{{*}}} unit, [TechType] type);

Returns true if the AI player has enough resources required to research the given tech type. If unit is not null, canResearch will return true only if the given unit can research the given tech type.

=== canUpgrade ===
bool canUpgrade([Unit]{{{*}}} unit, [UpgradeType] type);

Returns true if the AI player has enough resources required to upgrade the given upgrade type. If unit is not null, canUpgrade will return true only if the given unit can upgrade the given upgrade type.

=== getStartLocations ===
std::set< [Misc#TilePosition TilePosition] >& getStartLocations();

Returns the set of starting locations for the given map. To determine the starting location for the players in the current match, see [Player]::[Player#getStartLocation getStartLocation].

=== printf ===
void printf(const char {{{*}}}text, ...);

Prints text on the screen. Text is not sent to other players in multiplayer games.

=== sendText ===
void sendText(const char {{{*}}}text, ...);

Sends text to other players - as if it were entered in chat. In single player games and replays, this will just print the text on the screen. If the game is a single player match and not a replay, then this function can be used to execute cheat codes, i.e. Broodwar->sendText("show me the money").

=== changeRace ===
void changeRace([Race] race);

Used to change the race while in a lobby. Note that there is no onLobbyEnter callback yet, so this function cannot be used at this time.

=== isMultiplayer ===
bool isMultiplayer();

Returns true if Broodwar is in a multiplayer game. Returns false for single player games and replays.

=== isPaused ===
bool isPaused();

Returns true if Broodwar is paused. If the game is paused, Game::getFrameCount will continue to increase and AIModule::onFrame will still be called while paused.

=== isReplay ===
bool isReplay();

Returns true if Broodwar is in a replay.

=== startGame ===
void startGame();

Used to start the game while in a lobby. Note that there is no onLobbyEnter callback yet, so this function cannot be used at this time.

=== pauseGame ===
void pauseGame();

Pauses the game. If the game is paused, Game::getFrameCount will not increase however AIModule::onFrame will still be called while paused.

=== resumeGame ===
void resumeGame();

Resumes the game.

=== leaveGame ===
void leaveGame();

Leaves the current match and goes to the after-game stats screen.

=== restartGame ===
void restartGame();

Restarts the match. Works the same way as if you restarted the match from the menu screen. Only available in single player mode.

=== setLocalSpeed ===
void setLocalSpeed(int speed);

Sets the speed of the game to the given number. Lower numbers are faster. 0 is the fastest speed Starcraft can handle (which is about as fast as the fastest speed you can view a replay at). Any negative value will reset the speed to the starcraft default.

=== getSelectedUnits ===
std::set<[Unit]{{{*}}}>& getSelectedUnits();

Returns the set of units currently selected by the user in the GUI. If [Flag]::UserInput was not enabled during the [AIModule]::[AIModule#onStart onStart] callback, this function will always return an empty set.

=== self ===
[Player]{{{*}}} self();

Returns a pointer to the player that BWAPI controls. In replays this will return null.

=== enemy ===
[Player]{{{*}}} enemy();

Returns a pointer to the enemy player. If there is more than one enemy, this returns a pointer to just one enemy (see [#getPlayers getPlayers] and [Player]::[Player#isEnemy isEnemy] to get the other enemies). In replays this will return null.

=== drawText ===
  * void drawText(CoordinateType::Enum ctype, int x, int y, const char{{{*}}} text, ...);
  * void drawTextMap(int x, int y, const char{{{*}}} text, ...);
  * void drawTextMouse(int x, int y, const char{{{*}}} text, ...);
  * void drawTextScreen(int x, int y, const char{{{*}}} text, ...);

Draws text on the screen at the given position. Text can be drawn in different colors by using the following control characters:

[http://imgur.com/pDizc.png]

=== drawBox ===
  * void drawBox(CoordinateType::Enum ctype, int left, int top, int right, int bottom, Color color = Color(BWAPI::Colors::Green), bool isSolid = false);
  * void drawBoxMap(int left, int top, int right, int bottom, Color color = Color(BWAPI::Colors::Green), bool isSolid = false);
  * void drawBoxMouse(int left, int top, int right, int bottom, Color color = Color(BWAPI::Colors::Green), bool isSolid = false);
  * void drawBoxScreen(int left, int top, int right, int bottom, Color color = Color(BWAPI::Colors::Green), bool isSolid = false);

Draws a box on the screen, with the given color. If isSolid is true, the entire box will be rendered, otherwise just the outline will be drawn.

=== drawCircle ===
  * void drawCircle(CoordinateType::Enum ctype, int x, int y, int radius, Color color = Color(BWAPI::Colors::Green), bool isSolid = false);
  * void drawCircleMap(int x, int y, int radius, Color color = Color(BWAPI::Colors::Green), bool isSolid = false);
  * void drawCircleMouse(int x, int y, int radius, Color color = Color(BWAPI::Colors::Green), bool isSolid = false);
  * void drawCircleScreen(int x, int y, int radius, Color color = Color(BWAPI::Colors::Green), bool isSolid = false);

Draws a circle on the screen, with the given color. If isSolid is true, a solid circle is drawn, otherwise just the outline of a circle will be drawn.

=== drawEllipse ===
  * void drawEllipse(CoordinateType::Enum ctype, int x, int y, int xrad, int yrad, Color color = Color(BWAPI::Colors::Green), bool isSolid = false);
  * void drawEllipseMap(int x, int y, int xrad, int yrad, Color color = Color(BWAPI::Colors::Green), bool isSolid = false);
  * void drawEllipseMouse(int x, int y, int xrad, int yrad, Color color = Color(BWAPI::Colors::Green), bool isSolid = false);
  * void drawEllipseScreen(int x, int y, int xrad, int yrad, Color color = Color(BWAPI::Colors::Green), bool isSolid = false);

Draws an ellipse on the screen, with the given color. If isSolid is true, a solid ellipse is drawn, otherwise just the outline of an ellipse will be drawn.

=== drawDot ===
  * void drawDot(CoordinateType::Enum ctype, int x, int y, Color color = Color(BWAPI::Colors::Green));
  * void drawDotMap(int x, int y, Color color = Color(BWAPI::Colors::Green));
  * void drawDotMouse(int x, int y, Color color = Color(BWAPI::Colors::Green));
  * void drawDotScreen(int x, int y, Color color = Color(BWAPI::Colors::Green));

Draws a dot on the screen at the given position with the given color.

=== drawLine ===
  * void drawLine(CoordinateType::Enum ctype, int x1, int y1, int x2, int y2, Color color = Color(BWAPI::Colors::Green));
  * void drawLineMap(int x1, int y1, int x2, int y2, Color color = Color(BWAPI::Colors::Green));
  * void drawLineMouse(int x1, int y1, int x2, int y2, Color color = Color(BWAPI::Colors::Green));
  * void drawLineScreen(int x1, int y1, int x2, int y2, Color color = Color(BWAPI::Colors::Green));

Draws a line on the screen from (x1,y1) to (x2,y2) with the given color.

=== drawTriangle ===
  * void drawTriangle(CoordinateType::Enum ctype, int ax, int ay, int bx, int by, int cx, int cy, Color color = Color(BWAPI::Colors::Green), bool isSolid = false);
  * void drawTriangleMap(int ax, int ay, int bx, int by, int cx, int cy, Color color = Color(BWAPI::Colors::Green), bool isSolid = false);
  * void drawTriangleMouse(int ax, int ay, int bx, int by, int cx, int cy, Color color = Color(BWAPI::Colors::Green), bool isSolid = false);
  * void drawTriangleScreen(int ax, int ay, int bx, int by, int cx, int cy, Color color = Color(BWAPI::Colors::Green), bool isSolid = false);

Draws a triangle on the screen. If isSolid is true, a solid triangle is drawn, otherwise just the outline of the triangle will be drawn.