#summary User's guide
#sidebar TableOfContents

This article attempts to explain how your code will interact with Broodwar. For a basic explanation of the interfaces and naming see [Interfaces Interfaces].

General
  * [#Getting_started Getting started]
BWAPIv3.x
  * [#Control Control]
  * [#BWAPI2 BWAPI2]
  * [#BWAPI1 BWAPI1]
BWAPIv2.x
  * [#Comparison Comparison]

==Getting started==
To program AIs using BWAPI you will need to have the following installed:
  * [http://www.blizzard.com/us/broodwar/ Starcraft: Broodwar] [http://us.blizzard.com/support/article.xml?locale=en_US&articleId=21149 1.16.1]
  * [http://www.teamliquid.net/forum/viewmessage.php?topic_id=65196 Chaoslauncher]
  * A C++ compiler (such as Visual Studio 2008 [http://www.microsoft.com/downloads/details.aspx?FamilyId=FBEE1648-7106-44A7-9649-6D9F6D58056E&displaylang=en SP1] or [http://www.microsoft.com/express/download/#webInstall Visual C++ 2008 Express Edition])

Once you have those, download [http://bwapi.googlecode.com/files/BWAPI_Beta_2.6.1.zip BWAPI Beta 2.6.1] and follow the instructions in the readme on how to build the example AI module. It will explain where to place files and how to compile a sort of "Hello World"-like AI Module for BWAPI, which you can work from to start making your own custom Broodwar AI.

To battle 2 custom AIs against each other, or to play against your own custom AI, you'll need to have Broodwar running on 2 computers and make a multiplayer UDP LAN game (as if 2 humans were playing a match). This is because BWAPI controls the user's player and injects commands as if they were coming from the user.

Once you understand how the Example AI Module works, feel free to download the [http://code.google.com/p/bwsal/downloads/list Basic AI Module] from the [http://code.google.com/p/bwsal/ BWSAL project], which aims to develop several add-ons for BWAPI that will be useful for a wide variety of AIs.

=BWAPIv3.x=
==Control==
BWAPI let's you manipulate Broodwar in the same technical way as a human player would. But like most games, Broodwar computes the game state frame by frame. Without BWAPI, Broodwar runs through these steps:
  * Take user's commands
  * Compute next frame
  * Draw Screen
  * repeat
BWAPI intervenes right where Broodwar processes user's commands, and gives Broodwar AI's commands instead:
  * *AI does it's thing*
  * Take *AI's* commands
  * Compute next frame
  * Draw Screen
  * repeat
Thus your AI, unlike a regular program, is bound by Broodwar's frame cycle. BWAPI explicitely gives control to the AI when the time has come (e.g. via callbacks), and the AI explicitely gives back control (e.g. by returning from those callbacks). During the *timeframe* where your AI is in control, you may read any data and issue any orders. You may even do so from a different thread than the one which invoked the callback (see [Multithreading]).

[http://bwapi.googlecode.com/svn/wiki/simpleTimeline.png]

The conrol passing reflects the mathematical representation of an AI. Imagine the AI as a function, that is passed the whole game state as parameter. It returns all orders and shapes that should be issued/drawn this frame. The function is called once each frame.
===BWAPI2===
This interface provides callbacks as means of passing conrol. But since there is only one timeframe, several callbacks are called in the same frame, hence the rule: BWAPI2 always calls onFrame last. Any other callback called before onFrame is in the same timeframe as the subsequent onFrame call. BWAPI2 does not guarantee in what order the other callbacks get called.

[http://bwapi.googlecode.com/svn/wiki/timelineBWAPI2.png]

Since all the callbacks are inside AI's timeframe, you do not have to worry about that and may query information and assign orders from any callback as you like.

===BWAPI1===
This interface does not provide callbacks for passing control. Instead, blocking and polling functions are used. Events like unit creation and user input are passed along with the rest of the game state data.

The blocking function is waitForEvent(). When it returns, the return value (an enum) determines the type of event. If the return value is OnMatchFrame, AI's timeframe begins.

[http://bwapi.googlecode.com/svn/wiki/timelineBWAPI1.png]

While blocking, the AI cannot run further computations. To make use of this time, you have a choice: Use [Multithreading] or polling. Or ofcourse, you may use both. The pollForEvent() function does not block. It immediately returns whether there is an event. If there is no event, you may continue your computations, but if pollForEvent() returns true, a subsequent call to waitForEvent() will not block but return immediately while also starting your timeframe. Here is the timeline:

[http://bwapi.googlecode.com/svn/wiki/timelineBWAPI1polling.png]

For more information see the BWAPI1 offline documentation which will be downloadable along with a BWAPIv3.x release.

=BWAPIv2.x=
==Comparison==
The above is only true for BWAPIv3.x. In BWAPIv2.x callbacks are called from different internal Broodwar steps and orders are executed directly without caching. As a result, you are not able to issue orders from e.g. the onSendText callback. Here's the visual:

[http://bwapi.googlecode.com/svn/wiki/timelineBWAPIv2.png]